diff --git a/libavformat/bmxenc.c b/libavformat/bmxenc.c
index 6c846ab079..7dcc864ee2 100644
--- a/libavformat/bmxenc.c
+++ b/libavformat/bmxenc.c
@@ -5,6 +5,7 @@
 #include "avformat.h"
 #include "internal.h"
 #include "bmxenc.h"
+#include "mxf.h"
 
 #include <cbmx/essence_type.h>
 #include <cbmx/version.h>
@@ -42,6 +43,11 @@ static void bmx_writer_uninit(AVFormatContext *s)
     BMXContext* bmx = (BMXContext*)s->priv_data;
     bmx_uninit(bmx->internal_data);
     bmx->internal_data = NULL;
+    for (int i = 0; i < s->nb_streams; ++i)
+    {
+        AVStream* st = s->streams[i];
+        st->priv_data = NULL;
+    }
 }
 
 static int bmx_write_header(AVFormatContext *s)
@@ -52,6 +58,9 @@ static int bmx_write_header(AVFormatContext *s)
     for (int i = 0; i < s->nb_streams; ++i)
     {
         AVStream* st = s->streams[i];
+        BMXStreamContext* sc = av_mallocz(sizeof(BMXStreamContext));
+        st->priv_data = sc;
+
         EssenceType essence_type = UNKNOWN_ESSENCE_TYPE;
         switch(st->codecpar->codec_id) {
             case AV_CODEC_ID_MPEG2VIDEO:
@@ -144,9 +153,83 @@ static int bmx_write_header(AVFormatContext *s)
     }
 
     bmx_init(bmx->internal_data);
+
+    const MXFSamplesPerFrame *spf = NULL;
+    spf = ff_mxf_get_samples_per_frame(s, (AVRational){ s->streams[0]->time_base.num, s->streams[0]->time_base.den });
+    ff_audio_interleave_init(s, spf->samples_per_frame, s->streams[0]->time_base);
     return 0;
 }
 
+static int bmx_interleave_get_packet(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush)
+{
+    int i, stream_count = 0;
+
+    for (i = 0; i < s->nb_streams; i++)
+        stream_count += !!s->streams[i]->last_in_packet_buffer;
+
+    if (stream_count && (s->nb_streams == stream_count || flush)) {
+        AVPacketList *pktl = s->internal->packet_buffer;
+        if (s->nb_streams != stream_count) {
+            AVPacketList *last = NULL;
+            // find last packet in edit unit
+            while (pktl) {
+                if (!stream_count || pktl->pkt.stream_index == 0)
+                    break;
+                last = pktl;
+                pktl = pktl->next;
+                stream_count--;
+            }
+            // purge packet queue
+            while (pktl) {
+                AVPacketList *next = pktl->next;
+
+                if(s->streams[pktl->pkt.stream_index]->last_in_packet_buffer == pktl)
+                    s->streams[pktl->pkt.stream_index]->last_in_packet_buffer= NULL;
+                av_packet_unref(&pktl->pkt);
+                av_freep(&pktl);
+                pktl = next;
+            }
+            if (last)
+                last->next = NULL;
+            else {
+                s->internal->packet_buffer = NULL;
+                s->internal->packet_buffer_end= NULL;
+                goto out;
+            }
+            pktl = s->internal->packet_buffer;
+        }
+
+        *out = pktl->pkt;
+        av_log(s, AV_LOG_TRACE, "out st:%d dts:%"PRId64"\n", (*out).stream_index, (*out).dts);
+        s->internal->packet_buffer = pktl->next;
+        if(s->streams[pktl->pkt.stream_index]->last_in_packet_buffer == pktl)
+            s->streams[pktl->pkt.stream_index]->last_in_packet_buffer= NULL;
+        if(!s->internal->packet_buffer)
+            s->internal->packet_buffer_end= NULL;
+        av_freep(&pktl);
+        return 1;
+    } else {
+    out:
+        av_init_packet(out);
+        return 0;
+    }
+}
+
+static int bmx_compare_timestamps(AVFormatContext *s, AVPacket *next, AVPacket *pkt)
+{
+    BMXStreamContext *sc = s->streams[pkt->stream_index]->priv_data;
+    BMXStreamContext *sc2 = s->streams[next->stream_index]->priv_data;
+
+    return next->dts > pkt->dts ||
+        (next->dts == pkt->dts && sc->order < sc2->order);
+}
+
+static int bmx_interleave(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush)
+{
+    return ff_audio_rechunk_interleave(s, out, pkt, flush,
+                               bmx_interleave_get_packet, bmx_compare_timestamps);
+}
+
 static int bmx_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     BMXContext* bmx = (BMXContext*)s->priv_data;
@@ -169,6 +252,7 @@ static int bmx_write_footer(AVFormatContext *s)
 {
     BMXContext* bmx = (BMXContext*)s->priv_data;
     bmx_finish(bmx->internal_data);
+    ff_audio_interleave_close(s);
     return 0;
 }
 
@@ -221,18 +305,19 @@ static const AVClass bmx_class = {
 };
 
 AVOutputFormat ff_bmx_muxer = {
-    .name           = "bmx",
-    .long_name      = NULL_IF_CONFIG_SMALL("BMX Muxer"),
-    .mime_type      = "application/mxf",
-    .extensions     = "mxf",
-    .priv_data_size = sizeof(BMXContext),
-    .audio_codec    = AV_CODEC_ID_PCM_S16LE,
-    .video_codec    = AV_CODEC_ID_MPEG2VIDEO,
-    .flags          = AVFMT_NOTIMESTAMPS,
-    .init           = bmx_writer_init,
-    .write_header   = bmx_write_header,
-    .write_packet   = bmx_write_packet,
-    .write_trailer  = bmx_write_footer,
-    .deinit         = bmx_writer_uninit,
-    .priv_class     = &bmx_class,
+    .name               = "bmx",
+    .long_name          = NULL_IF_CONFIG_SMALL("BMX Muxer"),
+    .mime_type          = "application/mxf",
+    .extensions         = "mxf",
+    .priv_data_size     = sizeof(BMXContext),
+    .audio_codec        = AV_CODEC_ID_PCM_S16LE,
+    .video_codec        = AV_CODEC_ID_MPEG2VIDEO,
+    .flags              = AVFMT_NOTIMESTAMPS,
+    .init               = bmx_writer_init,
+    .write_header       = bmx_write_header,
+    .write_packet       = bmx_write_packet,
+    .interleave_packet  = bmx_interleave,
+    .write_trailer      = bmx_write_footer,
+    .deinit             = bmx_writer_uninit,
+    .priv_class         = &bmx_class,
 };
diff --git a/libavformat/bmxenc.h b/libavformat/bmxenc.h
index 98a2ace823..0aa31bd546 100644
--- a/libavformat/bmxenc.h
+++ b/libavformat/bmxenc.h
@@ -4,6 +4,9 @@
 
 #include "avformat.h"
 #include <cbmx/writer.h>
+#include <stdint.h>
+
+typedef uint8_t UID[16];
 
 typedef struct BMXContext {
     const AVClass* class;  /* Class for private options. */
@@ -23,6 +26,25 @@ typedef struct BMXContext {
     int loose_checks;
 } BMXContext;
 
+typedef struct BMXStreamContext {
+    AudioInterleaveContext aic;
+    UID track_essence_element_key;
+    int index;               ///< index in mxf_essence_container_uls table
+    const UID *codec_ul;
+    int order;               ///< interleaving order if dts are equal
+    int interlaced;          ///< whether picture is interlaced
+    int field_dominance;     ///< tff=1, bff=2
+    int component_depth;
+    int color_siting;
+    int signal_standard;
+    int h_chroma_sub_sample;
+    int v_chroma_sub_sample;
+    int temporal_reordering;
+    AVRational aspect_ratio; ///< display aspect ratio
+    int closed_gop;          ///< gop is closed, used in mpeg-2 frame parsing
+    int video_bit_rate;
+} BMXStreamContext;
+
 int bmx_create_bmx_wrapper(AVFormatContext *s);
 void bmx_delete_bmx_wrapper(AVFormatContext *s);
 
