diff --git a/libavformat/Makefile b/libavformat/Makefile
index 0f340f74a0..15b79cfdeb 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -134,7 +134,7 @@ OBJS-$(CONFIG_BIT_DEMUXER)               += bit.o
 OBJS-$(CONFIG_BIT_MUXER)                 += bit.o
 OBJS-$(CONFIG_BITPACKED_DEMUXER)         += rawvideodec.o
 OBJS-$(CONFIG_BMV_DEMUXER)               += bmv.o
-OBJS-$(CONFIG_BMX_MUXER)                 += bmxenc.o
+OBJS-$(CONFIG_BMX_MUXER)                 += bmxenc.o audiointerleave.o
 OBJS-$(CONFIG_BOA_DEMUXER)               += boadec.o
 OBJS-$(CONFIG_BFSTM_DEMUXER)             += brstm.o
 OBJS-$(CONFIG_BRSTM_DEMUXER)             += brstm.o
diff --git a/libavformat/audiointerleave.c b/libavformat/audiointerleave.c
new file mode 100644
index 0000000000..2e83031bd6
--- /dev/null
+++ b/libavformat/audiointerleave.c
@@ -0,0 +1,148 @@
+/*
+ * Audio Interleaving functions
+ *
+ * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/fifo.h"
+#include "libavutil/mathematics.h"
+#include "avformat.h"
+#include "audiointerleave.h"
+#include "internal.h"
+
+void ff_audio_interleave_close(AVFormatContext *s)
+{
+    int i;
+    for (i = 0; i < s->nb_streams; i++) {
+        AVStream *st = s->streams[i];
+        AudioInterleaveContext *aic = st->priv_data;
+
+        if (aic && st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
+            av_fifo_freep(&aic->fifo);
+    }
+}
+
+int ff_audio_interleave_init(AVFormatContext *s,
+                             const int samples_per_frame,
+                             AVRational time_base)
+{
+    int i;
+
+    if (!time_base.num) {
+        av_log(s, AV_LOG_ERROR, "timebase not set for audio interleave\n");
+        return AVERROR(EINVAL);
+    }
+    for (i = 0; i < s->nb_streams; i++) {
+        AVStream *st = s->streams[i];
+        AudioInterleaveContext *aic = st->priv_data;
+
+        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
+            int max_samples = samples_per_frame ? samples_per_frame :
+                              av_rescale_rnd(st->codecpar->sample_rate, time_base.num, time_base.den, AV_ROUND_UP);
+            aic->sample_size = (st->codecpar->channels *
+                                av_get_bits_per_sample(st->codecpar->codec_id)) / 8;
+            if (!aic->sample_size) {
+                av_log(s, AV_LOG_ERROR, "could not compute sample size\n");
+                return AVERROR(EINVAL);
+            }
+            aic->samples_per_frame = samples_per_frame;
+            aic->time_base = time_base;
+
+            if (!(aic->fifo = av_fifo_alloc_array(100, max_samples)))
+                return AVERROR(ENOMEM);
+            aic->fifo_size = 100 * max_samples;
+        }
+    }
+
+    return 0;
+}
+
+static int interleave_new_audio_packet(AVFormatContext *s, AVPacket *pkt,
+                                       int stream_index, int flush)
+{
+    AVStream *st = s->streams[stream_index];
+    AudioInterleaveContext *aic = st->priv_data;
+    int ret;
+    int nb_samples = aic->samples_per_frame ? aic->samples_per_frame :
+                     (av_rescale_q(aic->n + 1, av_make_q(st->codecpar->sample_rate, 1), av_inv_q(aic->time_base)) - aic->nb_samples);
+    int frame_size = nb_samples * aic->sample_size;
+    int size = FFMIN(av_fifo_size(aic->fifo), frame_size);
+    if (!size || (!flush && size == av_fifo_size(aic->fifo)))
+        return 0;
+
+    ret = av_new_packet(pkt, frame_size);
+    if (ret < 0)
+        return ret;
+    av_fifo_generic_read(aic->fifo, pkt->data, size, NULL);
+
+    if (size < pkt->size)
+        memset(pkt->data + size, 0, pkt->size - size);
+
+    pkt->dts = pkt->pts = aic->dts;
+    pkt->duration = av_rescale_q(nb_samples, st->time_base, aic->time_base);
+    pkt->stream_index = stream_index;
+    aic->dts += pkt->duration;
+    aic->nb_samples += nb_samples;
+    aic->n++;
+
+    return pkt->size;
+}
+
+int ff_audio_rechunk_interleave(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush,
+                        int (*get_packet)(AVFormatContext *, AVPacket *, AVPacket *, int),
+                        int (*compare_ts)(AVFormatContext *, const AVPacket *, const AVPacket *))
+{
+    int i, ret;
+
+    if (pkt) {
+        AVStream *st = s->streams[pkt->stream_index];
+        AudioInterleaveContext *aic = st->priv_data;
+        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
+            unsigned new_size = av_fifo_size(aic->fifo) + pkt->size;
+            if (new_size > aic->fifo_size) {
+                if (av_fifo_realloc2(aic->fifo, new_size) < 0)
+                    return AVERROR(ENOMEM);
+                aic->fifo_size = new_size;
+            }
+            av_fifo_generic_write(aic->fifo, pkt->data, pkt->size, NULL);
+        } else {
+            // rewrite pts and dts to be decoded time line position
+            pkt->pts = pkt->dts = aic->dts;
+            aic->dts += pkt->duration;
+            if ((ret = ff_interleave_add_packet(s, pkt, compare_ts)) < 0)
+                return ret;
+        }
+        pkt = NULL;
+    }
+
+    for (i = 0; i < s->nb_streams; i++) {
+        AVStream *st = s->streams[i];
+        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
+            AVPacket new_pkt = { 0 };
+            while ((ret = interleave_new_audio_packet(s, &new_pkt, i, flush)) > 0) {
+                if ((ret = ff_interleave_add_packet(s, &new_pkt, compare_ts)) < 0)
+                    return ret;
+            }
+            if (ret < 0)
+                return ret;
+        }
+    }
+
+    return get_packet(s, out, NULL, flush);
+}
diff --git a/libavformat/audiointerleave.h b/libavformat/audiointerleave.h
new file mode 100644
index 0000000000..0933310f4c
--- /dev/null
+++ b/libavformat/audiointerleave.h
@@ -0,0 +1,56 @@
+/*
+ * audio interleaving prototypes and declarations
+ *
+ * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_AUDIOINTERLEAVE_H
+#define AVFORMAT_AUDIOINTERLEAVE_H
+
+#include "libavutil/fifo.h"
+#include "avformat.h"
+
+typedef struct AudioInterleaveContext {
+    AVFifoBuffer *fifo;
+    unsigned fifo_size;           ///< size of currently allocated FIFO
+    int64_t n;                    ///< number of generated packets
+    int64_t nb_samples;           ///< number of generated samples
+    uint64_t dts;                 ///< current dts
+    int sample_size;              ///< size of one sample all channels included
+    int samples_per_frame;        ///< samples per frame if fixed, 0 otherwise
+    AVRational time_base;         ///< time base of output audio packets
+} AudioInterleaveContext;
+
+int ff_audio_interleave_init(AVFormatContext *s, const int samples_per_frame, AVRational time_base);
+void ff_audio_interleave_close(AVFormatContext *s);
+
+/**
+ * Rechunk audio PCM packets per AudioInterleaveContext->samples_per_frame
+ * and interleave them correctly.
+ * The first element of AVStream->priv_data must be AudioInterleaveContext
+ * when using this function.
+ *
+ * @param get_packet function will output a packet when streams are correctly interleaved.
+ * @param compare_ts function will compare AVPackets and decide interleaving order.
+ */
+int ff_audio_rechunk_interleave(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush,
+                        int (*get_packet)(AVFormatContext *, AVPacket *, AVPacket *, int),
+                        int (*compare_ts)(AVFormatContext *, const AVPacket *, const AVPacket *));
+
+#endif /* AVFORMAT_AUDIOINTERLEAVE_H */
diff --git a/libavformat/bmxenc.c b/libavformat/bmxenc.c
index 1b74068539..4af176c170 100644
--- a/libavformat/bmxenc.c
+++ b/libavformat/bmxenc.c
@@ -1,4 +1,5 @@
 
+#include "libavcodec/packet_internal.h"
 #include "libavutil/opt.h"
 #include "libavutil/internal.h"
 #include "audiointerleave.h"
@@ -13,14 +14,15 @@
 
 static int bmx_writer_init(AVFormatContext *s)
 {
+    struct MxfConfig config;
+    AVStream *st;
     BMXContext* bmx = (BMXContext*)s->priv_data;
 
     if(s->nb_streams < 1) {
         return -1;
     }
-    AVStream *st = s->streams[0];
+    st = s->streams[0];
 
-    struct MxfConfig config;
     config.clip_type = bmx->clip_type;
     config.shim_name = bmx->shim_name;
     config.ard_zdf_hdf = bmx->ard_zdf_hdf;
@@ -54,6 +56,8 @@ static void bmx_writer_uninit(AVFormatContext *s)
 static int bmx_write_header(AVFormatContext *s)
 {
     BMXContext* bmx = (BMXContext*)s->priv_data;
+    EssenceType essence_type = UNKNOWN_ESSENCE_TYPE;
+
     bmx->writers = (void**)av_malloc(s->nb_streams * sizeof(void*));
 
     for (int i = 0; i < s->nb_streams; ++i)
@@ -62,7 +66,6 @@ static int bmx_write_header(AVFormatContext *s)
         BMXStreamContext* sc = av_mallocz(sizeof(BMXStreamContext));
         st->priv_data = sc;
 
-        EssenceType essence_type = UNKNOWN_ESSENCE_TYPE;
         switch(st->codecpar->codec_id) {
             case AV_CODEC_ID_MPEG2VIDEO:
                 if(st->codecpar->width == 1920 && st->codecpar->height == 1080) {
@@ -148,7 +151,7 @@ static int bmx_write_header(AVFormatContext *s)
                     av_log(s, AV_LOG_INFO, "Set AVCI header for stream %d\n", i);
                 }
                 if (bmx->clip_type == CLIP_TYPE_D10) {
-                    bmx_set_aspect_ratio(bmx->internal_data, i, st->display_aspect_ratio.num, st->display_aspect_ratio.den);
+                    bmx_set_aspect_ratio(bmx->internal_data, i, st->internal->display_aspect_ratio.num, st->internal->display_aspect_ratio.den);
                 }
             }
         }
@@ -159,9 +162,7 @@ static int bmx_write_header(AVFormatContext *s)
         bmx_add_shim_metadata(bmx->internal_data, bmx->shim_name);
     }
 
-    const MXFSamplesPerFrame *spf = NULL;
-    spf = ff_mxf_get_samples_per_frame(s, (AVRational){ s->streams[0]->time_base.num, s->streams[0]->time_base.den });
-    ff_audio_interleave_init(s, spf->samples_per_frame, s->streams[0]->time_base);
+    ff_audio_interleave_init(s, 0, s->streams[0]->time_base);
     return 0;
 }
 
@@ -170,12 +171,12 @@ static int bmx_interleave_get_packet(AVFormatContext *s, AVPacket *out, AVPacket
     int i, stream_count = 0;
 
     for (i = 0; i < s->nb_streams; i++)
-        stream_count += !!s->streams[i]->last_in_packet_buffer;
+        stream_count += !!s->streams[i]->internal->last_in_packet_buffer;
 
     if (stream_count && (s->nb_streams == stream_count || flush)) {
-        AVPacketList *pktl = s->internal->packet_buffer;
+        PacketList *pktl = s->internal->packet_buffer;
         if (s->nb_streams != stream_count) {
-            AVPacketList *last = NULL;
+            PacketList *last = NULL;
             // find last packet in edit unit
             while (pktl) {
                 if (!stream_count || pktl->pkt.stream_index == 0)
@@ -186,10 +187,10 @@ static int bmx_interleave_get_packet(AVFormatContext *s, AVPacket *out, AVPacket
             }
             // purge packet queue
             while (pktl) {
-                AVPacketList *next = pktl->next;
+                PacketList *next = pktl->next;
 
-                if(s->streams[pktl->pkt.stream_index]->last_in_packet_buffer == pktl)
-                    s->streams[pktl->pkt.stream_index]->last_in_packet_buffer= NULL;
+                if(s->streams[pktl->pkt.stream_index]->internal->last_in_packet_buffer == pktl)
+                    s->streams[pktl->pkt.stream_index]->internal->last_in_packet_buffer= NULL;
                 av_packet_unref(&pktl->pkt);
                 av_freep(&pktl);
                 pktl = next;
@@ -207,15 +208,14 @@ static int bmx_interleave_get_packet(AVFormatContext *s, AVPacket *out, AVPacket
         *out = pktl->pkt;
         av_log(s, AV_LOG_TRACE, "out st:%d dts:%"PRId64"\n", (*out).stream_index, (*out).dts);
         s->internal->packet_buffer = pktl->next;
-        if(s->streams[pktl->pkt.stream_index]->last_in_packet_buffer == pktl)
-            s->streams[pktl->pkt.stream_index]->last_in_packet_buffer= NULL;
+        if(s->streams[pktl->pkt.stream_index]->internal->last_in_packet_buffer == pktl)
+            s->streams[pktl->pkt.stream_index]->internal->last_in_packet_buffer= NULL;
         if(!s->internal->packet_buffer)
             s->internal->packet_buffer_end= NULL;
         av_freep(&pktl);
         return 1;
     } else {
     out:
-        av_init_packet(out);
         return 0;
     }
 }
