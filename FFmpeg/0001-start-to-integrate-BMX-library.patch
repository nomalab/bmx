From fb8815c7e13c42f232337a353bdff853fbb1e94d Mon Sep 17 00:00:00 2001
From: Marc-Antoine Arnaud <arnaud.marcantoine@gmail.com>
Date: Wed, 31 Oct 2018 15:42:01 +0100
Subject: [PATCH 1/1] start to integrate BMX library
Content-Type: text/x-patch; charset="utf-8"

---
 configure                |  21 ++++++
 libavformat/Makefile     |   1 +
 libavformat/allformats.c |   1 +
 libavformat/bmx.cpp      | 146 ++++++++++++++++++++++++++++++++++++
 libavformat/bmx.hpp      |  11 +++
 libavformat/bmxenc.c     | 155 +++++++++++++++++++++++++++++++++++++++
 libavformat/bmxenc.h     |  34 +++++++++
 7 files changed, 369 insertions(+)
 create mode 100644 libavformat/bmx.cpp
 create mode 100644 libavformat/bmx.hpp
 create mode 100644 libavformat/bmxenc.c
 create mode 100644 libavformat/bmxenc.h

diff --git a/configure b/configure
index 85d5dd5962..556c21813d 100755
--- a/configure
+++ b/configure
@@ -222,6 +222,7 @@ External library support:
                            needed for subtitles and ass filter [no]
   --enable-libbluray       enable BluRay reading using libbluray [no]
   --enable-libbs2b         enable bs2b DSP library [no]
+  --enable-libcbmx         enable C-BMX library [no]
   --enable-libcaca         enable textual display using libcaca [no]
   --enable-libcelt         enable CELT decoding via libcelt [no]
   --enable-libcdio         enable audio CD grabbing with libcdio [no]
@@ -1387,6 +1388,7 @@ test_pkg_config(){
     test_cmd $pkg_config --exists --print-errors $pkg_version || return
     pkg_cflags=$($pkg_config --cflags $pkg_config_flags $pkg)
     pkg_libs=$($pkg_config --libs $pkg_config_flags $pkg)
+
     check_func_headers "$headers" "$funcs" $pkg_cflags $pkg_libs "$@" &&
         enable $name &&
         set_sanitized "${name}_cflags"    $pkg_cflags &&
@@ -1709,6 +1711,7 @@ EXTERNAL_LIBRARY_LIST="
     libass
     libbluray
     libbs2b
+    libcbmx
     libcaca
     libcelt
     libcodec2
@@ -3043,6 +3046,8 @@ trace_headers_bsf_select="cbs"
 vp9_metadata_bsf_select="cbs_vp9"
 
 # external libraries
+#bmx_muxer_deps="bmx"
+
 aac_at_decoder_deps="audiotoolbox"
 aac_at_decoder_select="aac_adtstoasc_bsf"
 ac3_at_decoder_deps="audiotoolbox"
@@ -3159,6 +3164,9 @@ asf_muxer_select="riffenc"
 asf_stream_muxer_select="asf_muxer"
 avi_demuxer_select="iso_media riffdec exif"
 avi_muxer_select="riffenc"
+cbmx_muxer_select="bmx_muxer"
+cbmx_muxer_deps="libcbmx"
+bmx_muxer_deps="libcbmx"
 caf_demuxer_select="iso_media riffdec"
 caf_muxer_select="iso_media"
 dash_muxer_select="mp4_muxer"
@@ -6017,6 +6025,17 @@ if ! disabled pthreads && ! enabled w32threads && ! enabled os2threads; then
     fi
 fi
 
+add_cflags -I/Users/marco/dev/nomalab/bmxlib-cbmx/include
+add_cflags -I/usr/local/include/bmx-0.1
+add_cflags -I/usr/local/include/libMXF++-1.0
+add_cflags -I/usr/local/include/libMXF-1.0
+add_cflags -fPIC
+#add_ldflags -lstdc++
+add_ldflags -lbmx-0.1
+add_ldflags -lMXF++-1.0
+add_ldflags -lMXF-1.0
+add_ldflags -L/Users/marco/dev/nomalab/bmxlib-cbmx/dist/lib/
+
 enabled  zlib && { check_pkg_config zlib zlib "zlib.h" zlibVersion ||
                    check_lib zlib   zlib.h      zlibVersion    -lz; }
 enabled bzlib && check_lib bzlib bzlib.h BZ2_bzlibVersion    -lbz2
@@ -6058,6 +6077,8 @@ enabled libiec61883       && require libiec61883 libiec61883/iec61883.h iec61883
 enabled libass            && require_pkg_config libass libass ass/ass.h ass_library_init
 enabled libbluray         && require_pkg_config libbluray libbluray libbluray/bluray.h bd_open
 enabled libbs2b           && require_pkg_config libbs2b libbs2b bs2b.h bs2b_open
+enabled libcbmx           && { check_pkg_config libcbmx libcbmx "cbmx/version.h" get_bmx_library_name ||
+                               require libcbmx "cbmx/version.h" get_bmx_library_name -lcbmx -lbmx-0.1 -lMXF++-1.0 -lMXF-1.0 -lstdc++; }
 enabled libcelt           && require libcelt celt/celt.h celt_decode -lcelt0 &&
                              { check_lib libcelt celt/celt.h celt_decoder_create_custom -lcelt0 ||
                                die "ERROR: libcelt must be installed and version must be >= 0.11.0."; }
diff --git a/libavformat/Makefile b/libavformat/Makefile
index e0222535c1..e73368c1af 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -124,6 +124,7 @@ OBJS-$(CONFIG_BINTEXT_DEMUXER)           += bintext.o sauce.o
 OBJS-$(CONFIG_BIT_DEMUXER)               += bit.o
 OBJS-$(CONFIG_BIT_MUXER)                 += bit.o
 OBJS-$(CONFIG_BMV_DEMUXER)               += bmv.o
+OBJS-$(CONFIG_BMX_MUXER)                 += bmx.o bmxenc.o
 OBJS-$(CONFIG_BOA_DEMUXER)               += boadec.o
 OBJS-$(CONFIG_BFSTM_DEMUXER)             += brstm.o
 OBJS-$(CONFIG_BRSTM_DEMUXER)             += brstm.o
diff --git a/libavformat/allformats.c b/libavformat/allformats.c
index 5c32ee6dff..4f07300d45 100644
--- a/libavformat/allformats.c
+++ b/libavformat/allformats.c
@@ -85,6 +85,7 @@ extern AVInputFormat  ff_bink_demuxer;
 extern AVInputFormat  ff_bit_demuxer;
 extern AVOutputFormat ff_bit_muxer;
 extern AVInputFormat  ff_bmv_demuxer;
+extern AVOutputFormat ff_bmx_muxer;
 extern AVInputFormat  ff_bfstm_demuxer;
 extern AVInputFormat  ff_brstm_demuxer;
 extern AVInputFormat  ff_boa_demuxer;
diff --git a/libavformat/bmx.cpp b/libavformat/bmx.cpp
new file mode 100644
index 0000000000..80b5bb32c4
--- /dev/null
+++ b/libavformat/bmx.cpp
@@ -0,0 +1,146 @@
+
+#include <cbmx/essence_type.h>
+#include <cbmx/version.h>
+#include <cbmx/writer.h>
+#include "bmx.hpp"
+#include "bmxenc.h"
+
+int bmx_create_bmx_wrapper(AVFormatContext *s)
+{
+    printf("CREATE BMX WRAPPER\n");
+
+    char * library_name = new char [100];
+    get_bmx_library_name(library_name);
+    printf("Library name: %s\n", library_name);
+
+    char * version = new char [100];
+    get_bmx_version_string(version);
+    printf("Version     : %s\n", version);
+
+    char * scm_version = new char [100];
+    get_bmx_version_string(scm_version);
+    printf("SCM version : %s\n", scm_version);
+
+    char * build = new char [100];
+    get_bmx_build_string(build);
+    printf("Build       : %s\n", build);
+
+    char * company = new char [100];
+    get_bmx_company_name(company);
+    printf("Company     : %s\n", company);
+
+    char * mxf_version = new char [100];
+    get_bmx_mxf_version_string(mxf_version);
+    printf("MXF Version : %s\n", mxf_version);
+
+    BMXContext* bmx = (BMXContext*)s->priv_data;
+    printf("Output filename: %s\n", s->url);
+
+    if(s->nb_streams < 1) {
+        return -1;
+    }
+    printf("NB Streams %d\n", s->nb_streams);
+    AVStream *st = s->streams[0];
+    printf("Timebase %d/%d\n", st->time_base.num, st->time_base.den);
+
+    switch(bmx->clip_type) {
+        case CLIP_TYPE_ASO2: {
+            printf("Clip format : AS-02\n");
+            bmx->priv_data = create_as02_writer(s->url, st->time_base.den, st->time_base.num);
+            break;
+        }
+        case CLIP_TYPE_OP1A: {
+            printf("Clip format : OP1a\n");
+            bmx->priv_data = create_op1a_writer(s->url, st->time_base.den, st->time_base.num);
+            break;
+        }
+        case CLIP_TYPE_AVID: {
+            printf("Clip format : AVID\n");
+            break;
+        }
+        case CLIP_TYPE_D10: {
+            printf("Clip format : D10\n");
+            break;
+        }
+        case CLIP_TYPE_RDD9: {
+            printf("Clip format : RDD9\n");
+            break;
+        }
+        case CLIP_TYPE_WAVE: {
+            printf("Clip format : WAVE\n");
+            break;
+        }
+        case CLIP_TYPE_NB: {
+            printf("Clip format : NB\n");
+            break;
+        }
+    }
+
+    return 0;
+}
+
+void bmx_delete_bmx_wrapper(AVFormatContext *s)
+{
+    BMXContext* bmx = (BMXContext*)s->priv_data;
+    bmx_uninit(bmx->priv_data);
+}
+
+
+void bmx_init_streams(AVFormatContext *s)
+{
+    BMXContext* bmx = (BMXContext*)s->priv_data;
+    bmx->writers = (void**)av_malloc(s->nb_streams * sizeof(void*));
+
+    for (int i = 0; i < s->nb_streams; ++i)
+    {
+        printf("Add stream %d\n", i);
+        AVStream* st = s->streams[i];
+        EssenceType essence_type = UNKNOWN_ESSENCE_TYPE;
+        switch(st->codecpar->codec_id) {
+            case AV_CODEC_ID_MPEG2VIDEO:
+                if(st->codecpar->width == 1920 && st->codecpar->height == 1080) {
+                    if(st->codecpar->field_order == AV_FIELD_PROGRESSIVE) {
+                        essence_type = MPEG2LG_422P_HL_1080P;
+                        break;
+                    } else {
+                        essence_type = MPEG2LG_422P_HL_1080I;
+                        break;
+                    }
+                }
+            case AV_CODEC_ID_H264:
+            case AV_CODEC_ID_PRORES:
+                break;
+            case AV_CODEC_ID_PCM_S24LE:
+                essence_type = WAVE_PCM;
+                // essence_type = D10_AES3_PCM;
+                break;
+            default:
+                break;
+        }
+        printf("Codec ID %d\n", essence_type);
+
+        if(essence_type != UNKNOWN_ESSENCE_TYPE) {
+            bmx->writers[i] = bmx_add_track(bmx->priv_data, essence_type);
+
+            if(st->codecpar->codec_id == AV_CODEC_ID_PCM_S24LE) {
+                bmx_set_quantization_bits(bmx->writers[i], 24);
+                bmx_channel_count(bmx->writers[i], 1);
+            }
+        }
+    }
+
+    bmx_init(bmx->priv_data);
+}
+
+
+void bmx_write(AVFormatContext *s, AVPacket *pkt)
+{
+    int num_samples = 1;
+
+    if(s->streams[pkt->stream_index]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
+        num_samples = pkt->size / (s->streams[pkt->stream_index]->codecpar->bits_per_raw_sample / 8);
+    }
+
+    BMXContext* bmx = (BMXContext*)s->priv_data;
+    bmx_write_sample(bmx->writers[pkt->stream_index], pkt->data, pkt->size, num_samples);
+}
diff --git a/libavformat/bmx.hpp b/libavformat/bmx.hpp
new file mode 100644
index 0000000000..59c5dd3abf
--- /dev/null
+++ b/libavformat/bmx.hpp
@@ -0,0 +1,11 @@
+#ifndef _FFMPEG_LIBAVFORMAT_BMX_HPP_
+#define _FFMPEG_LIBAVFORMAT_BMX_HPP_
+
+class BmxWrapper
+{
+public:
+    BmxWrapper();
+    ~BmxWrapper();
+};
+
+#endif
diff --git a/libavformat/bmxenc.c b/libavformat/bmxenc.c
new file mode 100644
index 0000000000..6e3b00cb09
--- /dev/null
+++ b/libavformat/bmxenc.c
@@ -0,0 +1,155 @@
+
+#include "libavutil/opt.h"
+#include "libavutil/internal.h"
+#include "audiointerleave.h"
+#include "avformat.h"
+#include "internal.h"
+#include "bmxenc.h"
+
+static int bmx_init(AVFormatContext *s)
+{
+    return bmx_create_bmx_wrapper(s);
+}
+
+static void bmx_deinit(AVFormatContext *s)
+{
+    bmx_delete_bmx_wrapper(s);
+}
+
+
+static int bmx_write_header(AVFormatContext *s)
+{
+    bmx_init_streams(s);
+    return 0;
+}
+
+static int bmx_write_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    bmx_write(s, pkt);
+    return 0;
+}
+
+static int bmx_write_footer(AVFormatContext *s)
+{
+    return 0;
+}
+
+/*
+static int bmx_interleave_get_packet(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush)
+{
+    int i, stream_count = 0;
+
+    for (i = 0; i < s->nb_streams; i++)
+        stream_count += !!s->streams[i]->last_in_packet_buffer;
+
+    if (stream_count && (s->nb_streams == stream_count || flush)) {
+        AVPacketList *pktl = s->internal->packet_buffer;
+        if (s->nb_streams != stream_count) {
+            AVPacketList *last = NULL;
+            // find last packet in edit unit
+            while (pktl) {
+                if (!stream_count || pktl->pkt.stream_index == 0)
+                    break;
+                last = pktl;
+                pktl = pktl->next;
+                stream_count--;
+            }
+            // purge packet queue
+            while (pktl) {
+                AVPacketList *next = pktl->next;
+
+                if(s->streams[pktl->pkt.stream_index]->last_in_packet_buffer == pktl)
+                    s->streams[pktl->pkt.stream_index]->last_in_packet_buffer= NULL;
+                av_packet_unref(&pktl->pkt);
+                av_freep(&pktl);
+                pktl = next;
+            }
+            if (last)
+                last->next = NULL;
+            else {
+                s->internal->packet_buffer = NULL;
+                s->internal->packet_buffer_end= NULL;
+                goto out;
+            }
+            pktl = s->internal->packet_buffer;
+        }
+
+        *out = pktl->pkt;
+        av_log(s, AV_LOG_TRACE, "out st:%d dts:%"PRId64"\n", (*out).stream_index, (*out).dts);
+        s->internal->packet_buffer = pktl->next;
+        if(s->streams[pktl->pkt.stream_index]->last_in_packet_buffer == pktl)
+            s->streams[pktl->pkt.stream_index]->last_in_packet_buffer= NULL;
+        if(!s->internal->packet_buffer)
+            s->internal->packet_buffer_end= NULL;
+        av_freep(&pktl);
+        return 1;
+    } else {
+    out:
+        av_init_packet(out);
+        return 0;
+    }
+}
+
+static int bmx_compare_timestamps(AVFormatContext *s, AVPacket *next, AVPacket *pkt)
+{
+    // BMXContext *sc  = s->streams[pkt ->stream_index]->priv_data;
+    // BMXContext *sc2 = s->streams[next->stream_index]->priv_data;
+
+    // return next->dts > pkt->dts ||
+    //     (next->dts == pkt->dts && sc->order < sc2->order);
+    return 0;
+}*/
+
+// static int bmx_interleave(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush)
+// {
+// //    return ff_audio_rechunk_interleave(s, out, pkt, flush,
+// //                               bmx_interleave_get_packet, bmx_compare_timestamps);
+//     return 0;
+// }
+
+// extern "C"
+// {
+
+#define OFFSET(x) offsetof(BMXContext, x)
+#define E AV_OPT_FLAG_ENCODING_PARAM
+static const AVOption options[] = {
+    { "clip_type", "set clip type", OFFSET(clip_type), AV_OPT_TYPE_INT, {.i64 = CLIP_TYPE_OP1A }, 0, CLIP_TYPE_NB - 1, E, "clip_type"},
+    { "as02", "Wrap an AS02 MXF", 0, AV_OPT_TYPE_CONST, {.i64 = CLIP_TYPE_ASO2 }, 0, UINT_MAX,   E, "clip_type"},
+    { "as11op1a", "Wrap an AS11 OP1A MXF", 0, AV_OPT_TYPE_CONST, {.i64 = CLIP_TYPE_AS11_OP1A }, 0, UINT_MAX,   E, "clip_type"},
+    { "as11d10", "Wrap an AS11 D10 MXF", 0, AV_OPT_TYPE_CONST, {.i64 = CLIP_TYPE_AS11_D10 }, 0, UINT_MAX,   E, "clip_type"},
+    { "op1a", "Wrap an OP1A MXF", 0, AV_OPT_TYPE_CONST, {.i64 = CLIP_TYPE_OP1A }, 0, UINT_MAX,   E, "clip_type"},
+    { "avid", "Wrap an Avid MXF", 0, AV_OPT_TYPE_CONST, {.i64 = CLIP_TYPE_AVID }, 0, UINT_MAX,   E, "clip_type"},
+    { "d10", "Wrap an D10 MXF", 0, AV_OPT_TYPE_CONST, {.i64 = CLIP_TYPE_D10 }, 0, UINT_MAX,   E, "clip_type"},
+    { "rdd9", "Wrap an RDD9 MXF", 0, AV_OPT_TYPE_CONST, {.i64 = CLIP_TYPE_RDD9 }, 0, UINT_MAX,   E, "clip_type"},
+    { "as10", "Wrap an AS10 MXF", 0, AV_OPT_TYPE_CONST, {.i64 = CLIP_TYPE_AS10 }, 0, UINT_MAX,   E, "clip_type"},
+    { "wave", "Wrap an WAVE MXF", 0, AV_OPT_TYPE_CONST, {.i64 = CLIP_TYPE_WAVE }, 0, UINT_MAX,   E, "clip_type"},
+
+    { "part", "Video essence partition interval in frames", OFFSET(part), AV_OPT_TYPE_DURATION, {.i64 = -1 }, -1, INT_MAX, E},
+
+    { NULL },
+};
+
+static const AVClass bmx_class = {
+    .class_name = "bmx muxer",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+AVOutputFormat ff_bmx_muxer = {
+    .name           = "bmx",
+    .long_name      = NULL_IF_CONFIG_SMALL("BMX Muxer"),
+    .mime_type      = "application/mxf",
+    .extensions     = "mxf",
+    .priv_data_size = sizeof(BMXContext),
+    .audio_codec    = AV_CODEC_ID_PCM_S16LE,
+    .video_codec    = AV_CODEC_ID_MPEG2VIDEO,
+    .flags          = AVFMT_NOTIMESTAMPS,
+    .init           = bmx_init,
+    .write_header   = bmx_write_header,
+    .write_packet   = bmx_write_packet,
+    .write_trailer  = bmx_write_footer,
+    .deinit         = bmx_deinit,
+    //.interleave_packet = bmx_interleave,
+    .priv_class     = &bmx_class,
+};
diff --git a/libavformat/bmxenc.h b/libavformat/bmxenc.h
new file mode 100644
index 0000000000..82ca32db2d
--- /dev/null
+++ b/libavformat/bmxenc.h
@@ -0,0 +1,34 @@
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "avformat.h"
+
+typedef enum {
+    CLIP_TYPE_ASO2 = 0,
+    CLIP_TYPE_AS11_OP1A,
+    CLIP_TYPE_AS11_D10,
+    CLIP_TYPE_OP1A,
+    CLIP_TYPE_AVID,
+    CLIP_TYPE_D10,
+    CLIP_TYPE_AS10,
+    CLIP_TYPE_RDD9,
+    CLIP_TYPE_WAVE,
+    CLIP_TYPE_NB
+} ClipType;
+
+typedef struct BMXContext {
+    ClipType clip_type;
+    float part;
+    void* priv_data;
+    void** writers;
+} BMXContext;
+
+int bmx_create_bmx_wrapper(AVFormatContext *s);
+void bmx_delete_bmx_wrapper(AVFormatContext *s);
+
+void bmx_init_streams(AVFormatContext *s);
+void bmx_write(AVFormatContext *s, AVPacket *pkt);
+
+#ifdef __cplusplus
+}
+#endif
-- 
2.19.1

